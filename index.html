<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>3D Endless Car Game - Premium</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --accent: #0096FF;
            --night-bg: #0b1020;
            --desert-bg: #e9b466;
            --forest-bg: #1a3b2d;
            --snow-bg: #a3c3d9;
            --city-bg: #3a3a3a;
            --beach-bg: #4fa49a;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        html, body { 
            height: 100%; 
            margin: 0; 
            background: var(--night-bg); 
            font-family: 'Segoe UI', Roboto, Ubuntu, sans-serif; 
            color: #eef3ff; 
            overflow: hidden; 
            touch-action: manipulation;
        }
        
        #game { 
            position: fixed; 
            inset: 0; 
            display: grid; 
            grid-template-rows: 1fr auto; 
        }
        
        #hud { 
            position: absolute; 
            top: 0; 
            left: 0; 
            right: 0; 
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
            padding: 10px 14px; 
            pointer-events: none; 
            font-weight: 700; 
            letter-spacing: .4px; 
            text-shadow: 0 2px 10px rgba(0,0,0,.6); 
            z-index: 5;
        }
        
        #score { font-size: 18px; }
        #speed { 
            font-size: 14px; 
            opacity: .85; 
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        #speedBar {
            width: 80px;
            height: 5px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            overflow: hidden;
        }
        
        #speedFill {
            height: 100%;
            width: 0%;
            background: var(--accent);
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        
        #fps { font-size: 12px; opacity: .6; }
        
        #highScore { 
            position: absolute; 
            top: 46px; 
            right: 14px; 
            font-size: 12px; 
            opacity: .7; 
            pointer-events: none; 
        }
        
        #currentMap { 
            position: absolute; 
            top: 46px; 
            left: 14px; 
            font-size: 12px; 
            opacity: .7; 
            pointer-events: none; 
        }

        #controls { 
            position: absolute; 
            left: 0; 
            right: 0; 
            bottom: 12px; 
            display: flex; 
            gap: 12px; 
            justify-content: center; 
            z-index: 5; 
        }
        
        .btn { 
            pointer-events: auto; 
            -webkit-tap-highlight-color: transparent; 
            padding: 14px 18px; 
            min-width: 110px; 
            border-radius: 18px; 
            border: none; 
            font-size: 16px; 
            font-weight: 800; 
            letter-spacing: .5px; 
            background: var(--accent); 
            color: #fff; 
            box-shadow: 0 8px 20px rgba(0,150,255,.35), inset 0 -2px 0 rgba(255,255,255,.2); 
            transition: transform .08s ease, filter .2s; 
            cursor: pointer;
        }
        
        .btn:active { 
            transform: translateY(2px); 
            filter: brightness(.95); 
        }
        
        .speed-btn { 
            min-width: 60px; 
            padding: 10px 14px; 
            font-size: 14px; 
        }

        #help { 
            position: absolute; 
            top: 46px; 
            left: 0; 
            right: 0; 
            text-align: center; 
            font-size: 12px; 
            opacity: .8; 
            pointer-events: none; 
        }

        #overlay { 
            position: absolute; 
            inset: 0; 
            display: none; 
            place-items: center; 
            background: radial-gradient(1200px 600px at 50% 100%, rgba(0,0,0,.65), rgba(0,0,0,.9)); 
            z-index: 10; 
        }
        
        #overlay.show { 
            display: grid; 
        }
        
        .card { 
            background: rgba(15,20,35,.9); 
            padding: 22px; 
            border-radius: 20px; 
            box-shadow: 0 20px 60px rgba(0,0,0,.6), inset 0 0 0 1px rgba(255,255,255,.06); 
            text-align: center; 
            width: min(92vw, 460px); 
        }
        
        .title { 
            font-size: 22px; 
            margin: 0 0 10px; 
        }
        
        .subtitle { 
            font-size: 14px; 
            opacity: .9; 
            margin: 0 0 18px; 
        }
        
        #countdown { 
            position: absolute; 
            inset: 0; 
            display: none; 
            place-items: center; 
            font-size: 120px; 
            font-weight: 800; 
            color: white; 
            text-shadow: 0 0 30px var(--accent); 
            z-index: 15; 
        }
        
        #countdown.show { 
            display: grid; 
        }
        
        #mapSelector { 
            position: absolute; 
            bottom: 70px; 
            left: 14px; 
            display: flex; 
            gap: 8px; 
            z-index: 5; 
            flex-wrap: wrap;
            max-width: 200px;
        }
        
        .map-btn { 
            width: 40px; 
            height: 40px; 
            border-radius: 10px; 
            border: 2px solid rgba(255,255,255,.3); 
            background: rgba(0,0,0,.4); 
            color: white; 
            font-size: 18px; 
            display: grid; 
            place-items: center; 
            cursor: pointer; 
        }
        
        .map-btn.active { 
            border-color: var(--accent); 
            background: rgba(0,150,255,.2); 
        }

        #speedControls { 
            position: absolute; 
            bottom: 70px; 
            right: 14px; 
            display: flex; 
            gap: 8px; 
            z-index: 5; 
        }
        
        #cameraControls {
            position: absolute;
            bottom: 120px;
            right: 14px;
            display: flex;
            gap: 8px;
            z-index: 5;
        }
        
        #carCustomization {
            position: absolute;
            top: 80px;
            left: 14px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 5;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(5px);
            max-width: 200px;
        }
        
        .color-picker {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
        }
        
        .color-option {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.2s;
        }
        
        .color-option:hover {
            transform: scale(1.1);
        }
        
        .color-option.selected {
            border-color: white;
            transform: scale(1.1);
        }
        
        #carSelection {
            position: absolute;
            top: 80px;
            right: 14px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 5;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(5px);
        }
        
        .car-option {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            display: grid;
            place-items: center;
            cursor: pointer;
            font-size: 20px;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        
        .car-option:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .car-option.selected {
            border-color: var(--accent);
            background: rgba(0, 150, 255, 0.2);
        }
        
        .section-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 5px;
            opacity: 0.9;
        }

        canvas { 
            display: block; 
            width: 100%; 
            height: 100%; 
        }
    </style>
</head>
<body>
<div id="game">
    <div id="hud">
        <div id="score">Score: 0</div>
        <div id="speed">
            <span>Speed: 0</span>
            <div id="speedBar"><div id="speedFill"></div></div>
        </div>
        <div id="fps"></div>
    </div>
    
    <div id="highScore">Best: 0</div>
    <div id="currentMap">Map: Night</div>
    <div id="help">Swipe left/right or use buttons. Avoid obstacles. 3 lanes.</div>

    <div id="controls">
        <button id="leftBtn" class="btn">‚üµ LEFT</button>
        <button id="rightBtn" class="btn">RIGHT ‚ü∂</button>
    </div>
    
    <div id="mapSelector">
        <div class="map-btn active" data-map="night">üåô</div>
        <div class="map-btn" data-map="desert">üåµ</div>
        <div class="map-btn" data-map="forest">üå≤</div>
        <div class="map-btn" data-map="snow">‚ùÑÔ∏è</div>
        <div class="map-btn" data-map="city">üèôÔ∏è</div>
        <div class="map-btn" data-map="beach">üèñÔ∏è</div>
    </div>
    
    <div id="speedControls">
        <button id="speedDown" class="btn speed-btn">-</button>
        <button id="speedUp" class="btn speed-btn">+</button>
    </div>
    
    <div id="cameraControls">
        <button id="cameraAngle1" class="btn speed-btn"><i class="fas fa-camera"></i> 1</button>
        <button id="cameraAngle2" class="btn speed-btn"><i class="fas fa-camera"></i> 2</button>
        <button id="cameraAngle3" class="btn speed-btn"><i class="fas fa-camera"></i> 3</button>
    </div>
    
    <div id="carCustomization">
        <div class="section-title">Car Color</div>
        <div class="color-picker">
            <div class="color-option selected" style="background: #0ea5ff;" data-color="0x0ea5ff"></div>
            <div class="color-option" style="background: #f24e1e;" data-color="0xf24e1e"></div>
            <div class="color-option" style="background: #ffcc00;" data-color="0xffcc00"></div>
            <div class="color-option" style="background: #aa55ff;" data-color="0xaa55ff"></div>
            <div class="color-option" style="background: #22c55e;" data-color="0x22c55e"></div>
            <div class="color-option" style="background: #ef4444;" data-color="0xef4444"></div>
            <div class="color-option" style="background: #ffffff;" data-color="0xffffff"></div>
            <div class="color-option" style="background: #000000;" data-color="0x000000"></div>
        </div>
    </div>
    
    <div id="carSelection">
        <div class="section-title">Car Model</div>
        <div style="display: flex; flex-direction: column; gap: 8px;">
            <div class="car-option selected" data-car="0">üöó</div>
            <div class="car-option" data-car="1">üèéÔ∏è</div>
            <div class="car-option" data-car="2">üöì</div>
            <div class="car-option" data-car="3">üöë</div>
            <div class="car-option" data-car="4">üöí</div>
            <div class="car-option" data-car="5">üöö</div>
            <div class="car-option" data-car="6">üèÅ</div>
            <div class="car-option" data-car="7">üöô</div>
            <div class="car-option" data-car="8">üöï</div>
            <div class="car-option" data-car="9">üöõ</div>
        </div>
    </div>

    <div id="countdown"></div>

    <div id="overlay">
        <div class="card">
            <h2 class="title">Game Over</h2>
            <p class="subtitle">Your score: <span id="finalScore">0</span></p>
            <p class="subtitle">High score: <span id="highScoreValue">0</span></p>
            <button id="restartBtn" class="btn" style="min-width:160px">RESTART</button>
        </div>
    </div>
</div>

<!-- Three.js from CDN -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

<script>
    (()=>{
      // Game settings
      const BASE_SPEED = 10;
      const MAX_SPEED = 500;
      const SPEED_INCREMENT = 2.0;
      
      // Map themes - 6 different maps
      const MAPS = {
        night: {
          background: 0x0b1020,
          road: 0x1b1f2f,
          shoulder: 0x273147,
          marker: 0xffffff,
          fogColor: 0x0b1020,
          fogNear: 50,
          fogFar: 120,
          treeTrunk: 0x6a4b36,
          treeLeaf: 0x1ea34a,
          envColor: '#0b1020'
        },
        desert: {
          background: 0xe9b466,
          road: 0xb5651d,
          shoulder: 0xd4a76a,
          marker: 0xffdbac,
          fogColor: 0xe9b466,
          fogNear: 40,
          fogFar: 100,
          treeTrunk: 0x8b4513,
          treeLeaf: 0x228b22,
          envColor: '#e9b466'
        },
        forest: {
          background: 0x1a3b2d,
          road: 0x2c5545,
          shoulder: 0x3a6656,
          marker: 0xc8e6c9,
          fogColor: 0x1a3b2d,
          fogNear: 30,
          fogFar: 90,
          treeTrunk: 0x5d4037,
          treeLeaf: 0x66bb6a,
          envColor: '#1a3b2d'
        },
        snow: {
          background: 0xa3c3d9,
          road: 0xd1e0e8,
          shoulder: 0xffffff,
          marker: 0x4a6572,
          fogColor: 0xa3c3d9,
          fogNear: 30,
          fogFar: 100,
          treeTrunk: 0x5d4037,
          treeLeaf: 0xffffff,
          envColor: '#a3c3d9'
        },
        city: {
          background: 0x3a3a3a,
          road: 0x4a4a4a,
          shoulder: 0x5a5a5a,
          marker: 0xffcc00,
          fogColor: 0x3a3a3a,
          fogNear: 40,
          fogFar: 110,
          treeTrunk: 0x4e342e,
          treeLeaf: 0x33691e,
          envColor: '#3a3a3a'
        },
        beach: {
          background: 0x4fa49a,
          road: 0xf4a460,
          shoulder: 0xfad5a5,
          marker: 0xffffff,
          fogColor: 0x4fa49a,
          fogNear: 35,
          fogFar: 95,
          treeTrunk: 0x8b4513,
          treeLeaf: 0x32cd32,
          envColor: '#4fa49a'
        }
      };
      
      let currentMap = "night";
      let currentCarType = 0;
      let currentCarColor = 0x0ea5ff;
      let currentCameraAngle = 0;

      const laneWidth = 3.2;
      const lanes = [-1, 0, 1];
      const laneX = lanes.map(i => i * laneWidth);

      // Renderer
      const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      // Scene & Camera
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(MAPS[currentMap].background);
      scene.fog = new THREE.Fog(MAPS[currentMap].fogColor, MAPS[currentMap].fogNear, MAPS[currentMap].fogFar);
      
      // Camera setup with multiple angles
      const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
      
      // Camera angles
      const cameraAngles = [
        { position: new THREE.Vector3(0, 6.5, 11.5), lookAt: new THREE.Vector3(0, 0.5, 0) }, // Default behind
        { position: new THREE.Vector3(0, 15, 0), lookAt: new THREE.Vector3(0, 0, 0) }, // Top down
        { position: new THREE.Vector3(0, 3, 8), lookAt: new THREE.Vector3(0, 1, 0) } // Front view
      ];
      
      function updateCamera() {
        const angle = cameraAngles[currentCameraAngle];
        camera.position.copy(angle.position);
        camera.lookAt(angle.lookAt);
      }
      
      updateCamera();

      // Lights
      const ambient = new THREE.AmbientLight(0xffffff, .6);
      scene.add(ambient);
      const dir = new THREE.DirectionalLight(0xffffff, .9);
      dir.position.set(6, 10, 10);
      dir.castShadow = true;
      scene.add(dir);

      // Road
      const roadGroup = new THREE.Group();
      scene.add(roadGroup);

      const roadMat = new THREE.MeshPhongMaterial({ color: MAPS[currentMap].road, shininess: 8 });
      const roadGeom = new THREE.PlaneGeometry(12, 500, 1, 1);
      const road = new THREE.Mesh(roadGeom, roadMat);
      road.rotation.x = -Math.PI/2;
      road.position.z = -200;
      road.receiveShadow = true;
      roadGroup.add(road);

      // Lane markers
      const markerMat = new THREE.MeshPhongMaterial({ color: MAPS[currentMap].marker, shininess: 30 });
      const dashLen = 2; const gap = 3; const totalLen = 500; const y = 0.01; const w = 0.1; const d = 0.6;
      function buildLaneMarkers(x){
        const g = new THREE.BoxGeometry(w, 0.02, d);
        const group = new THREE.Group();
        let z = -totalLen/2; const end = totalLen/2;
        while(z < end){
          const dash = new THREE.Mesh(g, markerMat);
          dash.position.set(x, y, z);
          group.add(dash);
          z += dashLen + gap;
        }
        return group;
      }
      const centerMarkers = buildLaneMarkers(0);
      roadGroup.add(centerMarkers);

      // Borders/shoulders
      const shoulderMat = new THREE.MeshPhongMaterial({ color: MAPS[currentMap].shoulder });
      const shoulderGeom = new THREE.PlaneGeometry(6, 500);
      const leftShoulder = new THREE.Mesh(shoulderGeom, shoulderMat);
      leftShoulder.rotation.x = -Math.PI/2; leftShoulder.position.set(-9, 0, -200);
      const rightShoulder = leftShoulder.clone(); rightShoulder.position.x = 9;
      roadGroup.add(leftShoulder, rightShoulder);

      // Trees
      const treeGroup = new THREE.Group(); scene.add(treeGroup);
      function makeTree(){
        const group = new THREE.Group();
        const trunkMat = new THREE.MeshPhongMaterial({ color: MAPS[currentMap].treeTrunk, shininess: 10 });
        const leafMat = new THREE.MeshPhongMaterial({ color: MAPS[currentMap].treeLeaf, shininess: 20 });
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.18, 1.1, 8), trunkMat);
        trunk.position.y = 0.55; 
        trunk.castShadow = true;
        group.add(trunk);
        const cone = new THREE.Mesh(new THREE.ConeGeometry(0.6, 1.4, 10), leafMat);
        cone.position.y = 1.5; 
        cone.castShadow = true;
        group.add(cone);
        return group;
      }

      const treePool = [];
      function spawnTree(zBase){
        const t = makeTree();
        const side = Math.random() < .5 ? -1 : 1;
        const lateral = 7 + Math.random()*2.5;
        t.position.set(side*lateral, 0, zBase);
        treeGroup.add(t);
        treePool.push(t);
      }

      // Car models - 10 different types
      function createCarModel(type, color) {
        const group = new THREE.Group();
        
        // Common wheel geometry and material
        const wheelGeom = new THREE.CylinderGeometry(.28, .28, .42, 14);
        const wheelMat = new THREE.MeshPhongMaterial({ color: 0x111, shininess: 30 });
        
        function wheel(x,z){ 
            const w = new THREE.Mesh(wheelGeom, wheelMat); 
            w.rotation.z = Math.PI/2; 
            w.position.set(x, .25, z); 
            w.castShadow = true;
            group.add(w); 
            return w; 
        }
        
        switch(type) {
            case 0: // Standard sedan
                const body = new THREE.Mesh(new THREE.BoxGeometry(1.6, .6, 2.6), new THREE.MeshPhongMaterial({ color: color, shininess: 80 }));
                body.position.y = .5; 
                body.castShadow = true;
                group.add(body);
                const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.4, .5, 1.2), new THREE.MeshPhongMaterial({ color: 0x1361a1, shininess: 90 }));
                cabin.position.set(0, .9, -0.2); 
                cabin.castShadow = true;
                group.add(cabin);
                wheel(-.8, .85); wheel(.8, .85); wheel(-.8, -1.0); wheel(.8, -1.0);
                break;
                
            case 1: // Sports car
                const sportBody = new THREE.Mesh(new THREE.BoxGeometry(1.5, .5, 2.4), new THREE.MeshPhongMaterial({ color: color, shininess: 100 }));
                sportBody.position.y = .45; 
                sportBody.castShadow = true;
                group.add(sportBody);
                const sportCabin = new THREE.Mesh(new THREE.BoxGeometry(1.3, .45, 1.0), new THREE.MeshPhongMaterial({ color: 0x1a1a1a, shininess: 90 }));
                sportCabin.position.set(0, .8, -0.3); 
                sportCabin.castShadow = true;
                group.add(sportCabin);
                const spoiler = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.8), new THREE.MeshPhongMaterial({ color: color, shininess: 80 }));
                spoiler.position.set(0, .7, -1.3);
                spoiler.castShadow = true;
                group.add(spoiler);
                wheel(-.75, .8); wheel(.75, .8); wheel(-.75, -0.9); wheel(.75, -0.9);
                break;
                
            case 2: // Police car
                const policeBody = new THREE.Mesh(new THREE.BoxGeometry(1.6, .6, 2.6), new THREE.MeshPhongMaterial({ color: 0xffffff, shininess: 80 }));
                policeBody.position.y = .5; 
                policeBody.castShadow = true;
                group.add(policeBody);
                const policeCabin = new THREE.Mesh(new THREE.BoxGeometry(1.4, .5, 1.2), new THREE.MeshPhongMaterial({ color: 0x1a1a1a, shininess: 90 }));
                policeCabin.position.set(0, .9, -0.2); 
                policeCabin.castShadow = true;
                group.add(policeCabin);
                const lightBar = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.2, 0.2), new THREE.MeshPhongMaterial({ color: 0x0066cc, shininess: 100 }));
                lightBar.position.set(0, 1.1, 0);
                lightBar.castShadow = true;
                group.add(lightBar);
                wheel(-.8, .85); wheel(.8, .85); wheel(-.8, -1.0); wheel(.8, -1.0);
                break;
                
            // Additional car models would be defined here...
            default:
                // Default to standard sedan if type not found
                const defBody = new THREE.Mesh(new THREE.BoxGeometry(1.6, .6, 2.6), new THREE.MeshPhongMaterial({ color: color, shininess: 80 }));
                defBody.position.y = .5; 
                defBody.castShadow = true;
                group.add(defBody);
                const defCabin = new THREE.Mesh(new THREE.BoxGeometry(1.4, .5, 1.2), new THREE.MeshPhongMaterial({ color: 0x1361a1, shininess: 90 }));
                defCabin.position.set(0, .9, -0.2); 
                defCabin.castShadow = true;
                group.add(defCabin);
                wheel(-.8, .85); wheel(.8, .85); wheel(-.8, -1.0); wheel(.8, -1.0);
        }
        
        return group;
      }

      // Car container
      let car = createCarModel(currentCarType, currentCarColor);
      scene.add(car);

      let currentLaneIndex = 1;
      const laneIndexToX = (idx)=> laneX[idx-0];
      car.position.x = laneIndexToX(currentLaneIndex);

      // Obstacles
      const obstacleGroup = new THREE.Group();
      scene.add(obstacleGroup);
      const obstaclePool = [];
      
      // Multiple obstacle types
      function makeObstacle(){
        const types = [
          () => {
            // Box obstacle
            const g = new THREE.BoxGeometry(1.6, 1.0, 1.2);
            const m = new THREE.MeshPhongMaterial({ color: 0xf24e1e, shininess: 40 });
            const mesh = new THREE.Mesh(g, m);
            mesh.castShadow = true;
            return mesh;
          },
          () => {
            // Cone obstacle
            const g = new THREE.ConeGeometry(0.8, 1.5, 8);
            const m = new THREE.MeshPhongMaterial({ color: 0xffcc00, shininess: 40 });
            const mesh = new THREE.Mesh(g, m);
            mesh.rotation.x = Math.PI;
            mesh.castShadow = true;
            return mesh;
          },
          () => {
            // Cylinder obstacle
            const g = new THREE.CylinderGeometry(0.7, 0.7, 1.0, 12);
            const m = new THREE.MeshPhongMaterial({ color: 0xaa55ff, shininess: 40 });
            const mesh = new THREE.Mesh(g, m);
            mesh.castShadow = true;
            return mesh;
          }
        ];
        
        const type = Math.floor(Math.random() * types.length);
        return types[type]();
      }

      function spawnObstacle(){
        const obs = makeObstacle();
        const lane = lanes[Math.floor(Math.random()*lanes.length)];
        obs.position.set(laneX[lane+1], .5, -220);
        obstacleGroup.add(obs);
        obstaclePool.push(obs);
      }

      // Particles for effects
      const particleGroup = new THREE.Group();
      scene.add(particleGroup);
      const particlePool = [];
      
      function createParticle(x, y, z, color = 0xffffff) {
        const geometry = new THREE.SphereGeometry(0.1, 8, 8);
        const material = new THREE.MeshBasicMaterial({ color: color });
        const particle = new THREE.Mesh(geometry, material);
        particle.position.set(x, y, z);
        particle.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 4,
          Math.random() * 3,
          (Math.random() - 0.5) * 2
        );
        particle.life = 1.0;
        particleGroup.add(particle);
        particlePool.push(particle);
        return particle;
      }
      
      function updateParticles(dt) {
        for (let i = particlePool.length - 1; i >= 0; i--) {
          const p = particlePool[i];
          p.life -= dt * 2;
          if (p.life <= 0) {
            particleGroup.remove(p);
            particlePool.splice(i, 1);
            continue;
          }
          
          p.position.add(p.velocity.clone().multiplyScalar(dt));
          p.velocity.y -= 9.8 * dt;
          p.scale.setScalar(p.life);
          p.material.opacity = p.life;
        }
      }

      // Gameplay state
      let running = true;
      let speed = BASE_SPEED;
      let time = 0;
      let score = 0;
      let lastSpawn = 0;
      let spawnInterval = 1.1;
      let lastTree = 0;
      let highScore = localStorage.getItem('highScore') || 0;
      const clock = new THREE.Clock();

      // UI
      const scoreEl = document.getElementById('score');
      const speedEl = document.getElementById('speed');
      const speedFillEl = document.getElementById('speedFill');
      const fpsEl = document.getElementById('fps');
      const overlay = document.getElementById('overlay');
      const finalScoreEl = document.getElementById('finalScore');
      const highScoreEl = document.getElementById('highScore');
      const highScoreValueEl = document.getElementById('highScoreValue');
      const countdownEl = document.getElementById('countdown');
      const currentMapEl = document.getElementById('currentMap');
      
      highScoreEl.textContent = `Best: ${highScore}`;
      currentMapEl.textContent = `Map: ${currentMap.charAt(0).toUpperCase() + currentMap.slice(1)}`;

      // Controls
      const leftBtn = document.getElementById('leftBtn');
      const rightBtn = document.getElementById('rightBtn');
      leftBtn.addEventListener('click', ()=> moveLane(-1));
      rightBtn.addEventListener('click', ()=> moveLane(1));
      
      // Speed controls
      const speedUpBtn = document.getElementById('speedUp');
      const speedDownBtn = document.getElementById('speedDown');
      speedUpBtn.addEventListener('click', () => {
        if (running) {
          speed = Math.min(MAX_SPEED, speed + 10);
          // Add speed boost particles
          for (let i = 0; i < 15; i++) {
            createParticle(
              car.position.x,
              0.2,
              car.position.z - 1.2,
              0x00ff00
            );
          }
        }
      });
      speedDownBtn.addEventListener('click', () => {
        if (running) {
          speed = Math.max(BASE_SPEED, speed - 10);
        }
      });
      
      // Camera controls
      const cameraAngle1Btn = document.getElementById('cameraAngle1');
      const cameraAngle2Btn = document.getElementById('cameraAngle2');
      const cameraAngle3Btn = document.getElementById('cameraAngle3');
      
      cameraAngle1Btn.addEventListener('click', () => {
        currentCameraAngle = 0;
        updateCamera();
      });
      
      cameraAngle2Btn.addEventListener('click', () => {
        currentCameraAngle = 1;
        updateCamera();
      });
      
      cameraAngle3Btn.addEventListener('click', () => {
        currentCameraAngle = 2;
        updateCamera();
      });

      // Map selection
      const mapButtons = document.querySelectorAll('.map-btn');
      mapButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          if (btn.classList.contains('active')) return;
          
          mapButtons.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          
          const newMap = btn.getAttribute('data-map');
          changeMap(newMap);
        });
      });
      
      // Car selection
      const carOptions = document.querySelectorAll('.car-option');
      carOptions.forEach(option => {
        option.addEventListener('click', () => {
          if (option.classList.contains('selected')) return;
          
          carOptions.forEach(o => o.classList.remove('selected'));
          option.classList.add('selected');
          
          const carType = parseInt(option.getAttribute('data-car'));
          changeCar(carType);
        });
      });
      
      // Color selection
      const colorOptions = document.querySelectorAll('.color-option');
      colorOptions.forEach(option => {
        option.addEventListener('click', () => {
          if (option.classList.contains('selected')) return;
          
          colorOptions.forEach(o => o.classList.remove('selected'));
          option.classList.add('selected');
          
          const colorValue = option.getAttribute('data-color');
          changeCarColor(parseInt(colorValue));
        });
      });

      // Map changing function
      function changeMap(mapName) {
        currentMap = mapName;
        currentMapEl.textContent = `Map: ${currentMap.charAt(0).toUpperCase() + currentMap.slice(1)}`;
        
        // Update scene
        scene.background = new THREE.Color(MAPS[currentMap].background);
        scene.fog = new THREE.Fog(MAPS[currentMap].fogColor, MAPS[currentMap].fogNear, MAPS[currentMap].fogFar);
        
        // Update road materials
        roadMat.color.set(MAPS[currentMap].road);
        shoulderMat.color.set(MAPS[currentMap].shoulder);
        markerMat.color.set(MAPS[currentMap].marker);
        
        // Update trees
        treePool.forEach(tree => {
          tree.children[0].material.color.set(MAPS[currentMap].treeTrunk); // trunk
          tree.children[1].material.color.set(MAPS[currentMap].treeLeaf);  // leaves
        });
        
        // Change body background color
        document.body.style.background = MAPS[currentMap].envColor;
      }
      
      // Car changing function
      function changeCar(type) {
        currentCarType = type;
        
        // Remove current car
        scene.remove(car);
        
        // Create new car
        car = createCarModel(currentCarType, currentCarColor);
        scene.add(car);
        
        // Position the new car correctly
        car.position.x = laneIndexToX(currentLaneIndex);
        car.position.y = 0.02;
        car.position.z = 0;
      }
      
      // Car color changing function
      function changeCarColor(color) {
        currentCarColor = color;
        
        // Update car material
        changeCar(currentCarType);
      }

      // Touch (swipe)
      let touchStartX = 0, touchEndX = 0;
      window.addEventListener('touchstart', e=>{ if(!running) return; touchStartX = e.changedTouches[0].clientX; }, {passive:true});
      window.addEventListener('touchend', e=>{ if(!running) return; touchEndX = e.changedTouches[0].clientX; const dx = touchEndX - touchStartX; if(Math.abs(dx) > 40){ if(dx>0) moveLane(1); else moveLane(-1); } }, {passive:true});

      // Keyboard for desktop testing
      window.addEventListener('keydown', (e)=>{
        if(e.key === 'ArrowLeft' || e.key === 'a') moveLane(-1);
        if(e.key === 'ArrowRight' || e.key === 'd') moveLane(1);
        if(!running && (e.key==='Enter' || e.key===' ')) restart();
        if(e.key === '+' || e.key === '=') speedUpBtn.click();
        if(e.key === '-' || e.key === '_') speedDownBtn.click();
        if(e.key === '1') cameraAngle1Btn.click();
        if(e.key === '2') cameraAngle2Btn.click();
        if(e.key === '3') cameraAngle3Btn.click();
      });

      function moveLane(dir){
        if(!running) return;
        const targetIdx = THREE.MathUtils.clamp(currentLaneIndex + dir, 0, 2);
        if(targetIdx === currentLaneIndex) return;
        currentLaneIndex = targetIdx;
        
        // Add movement particles
        for (let i = 0; i < 8; i++) {
          createParticle(
            car.position.x,
            0.2,
            car.position.z - 1.2,
            0x0096FF
          );
        }
      }

      function updateCar(dt){
        // Smooth X tween
        const targetX = laneIndexToX(currentLaneIndex);
        car.position.x = THREE.MathUtils.damp(car.position.x, targetX, 12, dt);
        // Tiny bobbing
        car.position.y = 0.02 + Math.sin(time*8)*0.02;
        
        // Add speed particles occasionally
        if (Math.random() < 0.3) {
          createParticle(
            car.position.x + (Math.random() - 0.5) * 1.5,
            0.1,
            car.position.z - 1.5 - Math.random() * 0.5,
            0xffffff
          );
        }
      }

      // Collision helpers
      const carBB = new THREE.Box3();
      const tmpBB = new THREE.Box3();

      function updateObstacles(dt){
        // Spawn
        if(time - lastSpawn > spawnInterval){
          spawnObstacle();
          lastSpawn = time;
          // Increase difficulty
          if(spawnInterval > .5) spawnInterval -= 0.02;
        }
        // Move towards camera (positive z)
        for(let i=obstaclePool.length-1;i>=0;i--){
          const o = obstaclePool[i];
          o.position.z += speed * dt;
          // remove if passed
          if(o.position.z > 12){
            obstacleGroup.remove(o);
            obstaclePool.splice(i,1);
            score += 10; // reward for dodging
          }
        }

        // Collision check
        carBB.setFromObject(car);
        for(const o of obstaclePool){
          tmpBB.setFromObject(o);
          if(carBB.intersectsBox(tmpBB)){
            gameOver();
            break;
          }
        }
      }

      function updateTrees(dt){
        // Spawn trees every ~6 units in z space
        if(time - lastTree > 0.08){
          spawnTree(-220);
          lastTree = time;
        }
        // Move forward with world flow
        for(let i=treePool.length-1;i>=0;i--){
          const t = treePool[i];
          t.position.z += speed * dt * 0.98;
          if(t.position.z > 30){
            treeGroup.remove(t);
            treePool.splice(i,1);
          }
        }
      }

      function updateMarkers(dt){
        // scroll markers group forward by moving its position.z and wrapping
        centerMarkers.position.z += speed * dt;
        road.position.z += speed * dt * 0.98;
        leftShoulder.position.z = road.position.z;
        rightShoulder.position.z = road.position.z;
        if(centerMarkers.position.z > 150){
          centerMarkers.position.z = -150; // wrap
        }
        if(road.position.z > 0){ road.position.z = -200; }
      }

      function gameOver(){
        running = false;
        finalScoreEl.textContent = score.toString();
        
        // Update high score
        if (score > highScore) {
          highScore = score;
          localStorage.setItem('highScore', highScore);
          highScoreEl.textContent = `Best: ${highScore}`;
        }
        
        highScoreValueEl.textContent = highScore.toString();
        overlay.classList.add('show');
        
        // Create explosion particles
        for (let i = 0; i < 30; i++) {
          createParticle(
            car.position.x,
            car.position.y + 0.5,
            car.position.z,
            0xf24e1e
          );
        }
      }

      function startCountdown() {
        return new Promise(resolve => {
          countdownEl.classList.add('show');
          let count = 3;
          
          function updateCountdown() {
            if (count > 0) {
              countdownEl.textContent = count;
              count--;
              setTimeout(updateCountdown, 1000);
            } else {
              countdownEl.textContent = "GO!";
              setTimeout(() => {
                countdownEl.classList.remove('show');
                resolve();
              }, 500);
            }
          }
          
          updateCountdown();
        });
      }

      async function restart(){
        // Clear obstacles & trees
        obstaclePool.forEach(o=> obstacleGroup.remove(o));
        obstaclePool.length = 0;
        treePool.forEach(t=> treeGroup.remove(t));
        treePool.length = 0;
        particlePool.forEach(p=> particleGroup.remove(p));
        particlePool.length = 0;
        
        // Reset game state
        speed = BASE_SPEED;
        spawnInterval = 1.1;
        score = 0;
        time = 0;
        lastSpawn = 0;
        lastTree = 0;
        currentLaneIndex = 1;
        car.position.x = laneIndexToX(currentLaneIndex);
        overlay.classList.remove('show');
        
        // Show countdown
        await startCountdown();
        
        running = true;
      }

      document.getElementById('restartBtn').addEventListener('click', restart);

      // Resize
      window.addEventListener('resize', ()=>{
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // FPS display
      let fpsLast = performance.now();
      let frames = 0;

      // Pre-seed some trees along the road
      for(let i=0;i<90;i++) spawnTree(-220 + i*3);

      // Main loop
      function animate(){
        const dt = Math.min(clock.getDelta(), 0.033);
        if(running){
          time += dt;
          speed = Math.min(MAX_SPEED, speed + dt * SPEED_INCREMENT);
          score += Math.floor(dt * 15); // increased scoring
          updateCar(dt);
          updateObstacles(dt);
          updateTrees(dt);
          updateMarkers(dt);
          updateParticles(dt);
        }

        // UI
        scoreEl.textContent = `Score: ${score}`;
        speedEl.querySelector('span').textContent = `Speed: ${Math.round(speed)}`;
        speedFillEl.style.width = `${(speed / MAX_SPEED) * 100}%`;

        // FPS approx
        frames++;
        const now = performance.now();
        if(now - fpsLast >= 500){
          const fps = Math.round(frames * 1000 / (now - fpsLast));
          fpsEl.textContent = `${fps} FPS`;
          frames = 0; fpsLast = now;
        }

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      // Start the game with a countdown
      (async function() {
        await startCountdown();
        animate();
      })();
    })();
</script>
</body>
</html>
